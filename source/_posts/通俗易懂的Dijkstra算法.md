---
title: 通俗易懂的Dijkstra算法
date: 2024-05-14 20:28:53
tags: 
- Coding,Rust
---

看了下网上的一些讲的这个算法，有的说的太复杂了
<!--more-->
我们假设有A、B、C、D、E四个节点，我们想找到从A到E的最短路径（边权和最小）

我们定义$D_A(x)$表示**当前**计算出来的从A到X的最短距离

定义$C(X,Y)$表示从X**直接**到Y的距离

```
A——8——B
| ╲     ╲ 
2  18    15
|    ╲     ╲
C——9——D——11——E
```
## 文字描述
先构建一个映射$f: x \rightarrow D_A(x),x\in\{B、C、D、E\}$，再构建一个集合$c:\{\}$来存放已经寻找过了的节点。
### 初始化
初始从A开始直接寻找，然后将结果直接存放在$f$中，$c:\{A\}$

### 循环迭代
寻找$f$中值最小


## 图表描述
我们可以构建如下表,B、C、D列表示当前计算出的最短距离，即$D_A(X)$
，然后一步一步迭代计算
|已经搜索了的节点|B|C|D|E|说明|
|:---:|:---:|:---:|:---:|:---:|:---|
|A|8|2|18|$\infty$|从A开始直接寻找，发现C距离最短，下一步从C开始搜索
|AC|8|-|**11**|$\infty$|发现$D_A(C)+C(C,D)$比$D_A(D)$更小，遂更新$D_A(D)$的值；此时未搜索的节点中B的距离最短
|ACB|-|-|11|**23**|发现$D_A(B)+C(B,E)$比$D_A(E)$更小，遂更新
|ACBD|-|-|-|**22**|发现$D_A(D)+C(D,E)$比$D_A(E)$更小，遂更新

注意，当把


